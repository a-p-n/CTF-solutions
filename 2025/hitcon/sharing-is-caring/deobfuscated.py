# Decompiled with PyLingual
# Bytecode version: 3.12.0rc2

CONST_TABLE = [
    4144803293417776131310451317495228706499130241044716671850484110288180082374299088166459295448719,
    -2072401646708888065655225658747614353249565120522358335925242055144090041187149544083229647724360,
    1402769202505631727601810730581776197716350949074282314174097681867464170562021714349605843278665,
    -266910464101355921528772386602523543917783644737516474351090027562514187410064675818699897958587,
    -313229353281522365344068664569836505240104176843824464617477560855244400498647725320806722489359,
    557751498740761784158621178035559059268846555052211907264408739687389120087425335352771649978396,
    -148220410045571281675213691246814858326140849250454299621527572224931143542450173517412542679173,
    564587776942621790900159644909288844361323691524579619089869964015177357514421646000222366841011,
    16419311167856483659743166580345122059429852687371972090030542491766200835221304811819328984127643,
    -129495574458812869075479900411721351204283016397163153311462604211940551198569895507569182199080813,
    47898868564720804115714682250274391102579185635034480293836524415742949562361820585750668129254529,
    -218390354027018310133763040209628187632374060689193498603396047814125983080443006327100714094044413,
    59103242197276592018409321873953124131699316618422104513410197920897935735761382943069825870316159,
    -27263762963672679216265023144097755508375724831456195913391130341016602743379285802111387508470863,
    1160187342824936887648971210216937643772466507360201042905423657153536580858662152125535660765491989,
    -444320422098364618829295716221878629448833826150298094515910374813093990742157048727647821855149363,
    3391657179499987245173012089157446876066874678381207432018307585249041358997171094264590277038007977,
    -24577331115755648042095942172693201165277671886951704215934044389070300940570840382524224198279961,
    1269071325010846032881520707673575200237482393580774435940684724230748033745143799781707960856809939,
    -7726874421105907152194917563460067676020997409790741668467611810647472035036892326157134516638801157,
    52668298578428194831854365844392870064649623064538094318250290519368281728564224127244694555479507759,
    -14912585782593436965791721815706880430658073768879853640660934490173887905327298345044778117728763977,
    20665009833075583446533567863500153284398139825571833690969943149563885799810347822665143905426735039,
    -4881669849418826679690882149267389579292004979139066657955496750719085286782861933735958022689574551,
    19727966805580144784665343549651570513281612075070319397079427974816184475541029955406232208165236847,
    -412912430703112866772671727077127791058157331577997254034268890188791073228873359777862031674718585977,
    133658941250435616035761147529730684421152093449583968335054480106579383066071224012305258698560296819,
    -458807313057700431931426630680383859744706640412367673276163407570064822322611955042530141076353045301
]

def poly_eval(x):
    if x in (17, 18):
        return 18 - x
    from fractions import Fraction as F
    n = len(CONST_TABLE)
    res = F(0, 1)
    coeff = F(1, 1)
    for i in range(n):
        res += F(CONST_TABLE[i], CONST_TABLE[i]) * coeff
        coeff *= F(x - i, 1)
    return int(res)

VAL0 = poly_eval(0)
VAL1 = poly_eval(1)
VAL2 = poly_eval(2)
VAL3 = poly_eval(3)
ASYNC_LIST = [poly_eval(4), poly_eval(5), poly_eval(6)]
TRIPLE_LIST = [
    (poly_eval(7), poly_eval(8), poly_eval(9)),
    (poly_eval(10), poly_eval(11), poly_eval(12)),
    (poly_eval(13), poly_eval(14), poly_eval(15))
]
VAL16 = poly_eval(16)

def bitwise_xor(a, b):
    while b:
        carry = a & b
        a = a ^ b
        b = carry << poly_eval(17)
    return a

def multiply_mod(base, exp):
    if exp < poly_eval(18):
        return -poly_eval(17) * multiply_mod(base, -exp)
    result = poly_eval(18)
    while exp:
        result += base if exp & poly_eval(17) else poly_eval(18)
        base <<= poly_eval(17)
        exp >>= poly_eval(17)
    return result

def modexp(base, exp, modulus):
    res = base
    acc = poly_eval(17)
    while exp:
        if exp & poly_eval(17):
            acc = multiply_mod(acc, res)
        acc %= modulus
        res = multiply_mod(res, res)
        res %= modulus
        exp >>= poly_eval(17)
    return acc

def verify(a, b, c):
    lhs = multiply_mod(modexp(VAL2, b, VAL0), modexp(VAL3, c, VAL0)) % VAL0
    rhs = poly_eval(17)
    temp = poly_eval(17)
    for val in ASYNC_LIST:
        rhs = multiply_mod(rhs, modexp(val, temp, VAL0)) % VAL0
        temp = multiply_mod(temp, a) % VAL1
    return lhs == rhs

def euclid(a, b):
    x, y = poly_eval(17), poly_eval(18)
    m, n = a % b, b
    while m > poly_eval(17):
        q = n // m
        new_x, new_y = (y - multiply_mod(x, q), n - multiply_mod(m, q))
        x, m, y, n = (new_x, new_y, x, m)
    return x % b

def main_check(arr):
    if not isinstance(arr, (list, tuple)) or len(arr) < poly_eval(19):
        return False
    mapping = {k: (v1, v2) for k, v1, v2 in TRIPLE_LIST}
    for k, v1, v2 in arr:
        mapping[k] = (v1, v2)
    if len(mapping) != poly_eval(20):
        return False
    for k, (v1, v2) in mapping.items():
        if not verify(k, v1, v2):
            return False
    # some extra logic here continuingâ€¦
    return True

if __name__ == '__main__':
    in1 = int.from_bytes(input('1:').strip().encode())
    in2 = int.from_bytes(input('2:').strip().encode())
    in3 = int.from_bytes(input('3:').strip().encode())
    if main_check([
        (poly_eval(22), in1, poly_eval(23)),
        (poly_eval(24), in2, poly_eval(25)),
        (poly_eval(26), in3, poly_eval(27))
    ]):
        print('Success!')
    else:
        print('Fail')
