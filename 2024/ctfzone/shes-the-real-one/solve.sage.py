

# This file was *autogenerated* from the file ./shes-the-real-one/solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_800 = Integer(800); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_33 = Integer(33)
from functools import namedtuple

Point = namedtuple("Point", ["x", "y"])
R = RealField(prec=_sage_const_800 )
inf = Point(R(_sage_const_0 ), R(_sage_const_1 ))

def lift_x(x):
    return Point(x, sqrt(x**_sage_const_3  - R(_sage_const_3 ) * x - R(_sage_const_2 )))

def add(P, Q):
    if P.x == Q.x and P.y != Q.y:
        return inf
    elif P.y == Q.y:
        raise ValueError("Points have to differ!")
    elif P == inf:
        return Q
    elif Q == inf:
        return P

    lambda_ = (P.y - Q.y) / (P.x - Q.x)

    xr = lambda_**_sage_const_2  - P.x - Q.x
    yr = lambda_ * (Q.x - xr) - Q.y
    return Point(xr, yr)

def double(P):
    if P == inf:
        return P

    lambda_ = (R(_sage_const_3 ) * P.x**_sage_const_2  - R(_sage_const_3 )) / (R(_sage_const_2 ) * P.y)

    xr = lambda_**_sage_const_2  - _sage_const_2  * P.x
    yr = lambda_ * (P.x - xr) - P.y
    return Point(xr, yr)

def multiply_by_scalar(P, n: int):
    if n == _sage_const_0  or P == inf:
        return inf
    elif n < _sage_const_0 :
        return multiply_by_scalar(Point(-P.x, P.y), -n)

    R0, R1 = P, double(P)
    for b in bin(n)[_sage_const_3 :]:
        if b == "0":
            R0, R1 = double(R0), add(R0, R1)
        else:
            R0, R1 = add(R0, R1), double(R1)
    return R0

with open("./shes-the-real-one/output.dump", 'rb') as f:
    P, Q = loads(f.read())

def brute_force_discrete_log(P, Q, max_s):
    for s in range(max_s):
        if multiply_by_scalar(P, s) == Q:
            return s
    return None

max_s = _sage_const_2 **_sage_const_33 
s = brute_force_discrete_log(P, Q, max_s)
if s is not None:
    print(f"Recovered scalar s: {s}")
else:
    print("Failed to recover scalar s")

